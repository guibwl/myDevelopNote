# 事件机制

我们首先应该形成一个感性的认知：一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。

在 ES3 和更早的版本中，JavaScript 本身还没有异步执行代码的能力，这也就意味着，宿主环境传递给 JavaScript 引擎一段代码，引擎就把代码直接顺次执行了，这个任务也就是宿主发起的任务。

但是，在 ES5 之后，JavaScript 引入了 Promise，这样，不需要浏览器的安排，JavaScript 引擎本身也可以发起任务了。

由于我们这里主要讲 JavaScript 语言，那么采纳 JSC 引擎的术语，**我们把宿主发起的任务称为宏观任务（JavaScript 执行中最粗粒度的任务），把 JavaScript 引擎发起的任务称为微观任务。**

## 宏观和微观任务

JavaScript 引擎等待宿主环境分配宏观任务，在操作系统中，通常等待的行为都是一个事件循环，所以在 Node 术语中，也会把这个部分称为事件循环。

不过，术语本身并非我们需要重点讨论的内容，我们在这里把重点放在事件循环的原理上。在底层的 C/C++ 代码中，这个事件循环是一个跑在独立线程中的循环，我们用伪代码来表示，大概是这样的：

```js
while (TRUE) {
  r = wait();
  execute(r);
}
```

整个循环做的事情基本上就是反复“等待 - 执行”。当然，实际的代码中并没有这么简单，还有要判断循环是否结束、宏观任务队列等逻辑。

这里每次的执行过程，其实都是一个宏观任务。我们可以大概理解：宏观任务的队列就相当于事件循环。

在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列：

```
|------------------------------------------|
|  Macro Task                              |
| |------------|------------|------------| |
| | Micro Task | Micro Task | Micro Task | |
| |------------|------------|------------| |
|------------------------------------------|
|  Macro Task                              |
| |------------|------------|------------| |
| | Micro Task | Micro Task | Micro Task | |
| |------------|------------|------------| |
|------------------------------------------|
|  Macro Task                              |
|  ...                                     |
|------------------------------------------|
```

有了宏观任务和微观任务机制，我们就可以实现 JavaScript 引擎级和宿主级的任务了，例如：Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。

**宏任务：**

| API                   | Browser | Node |
| --------------------- | ------- | ---- |
| setTimeout            | √       | √    |
| setInterval           | √       | √    |
| setImmediate          | x       | √    |
| requestAnimationFrame | √       | x    |

**微任务：**

| API                        | Browser | Node |
| -------------------------- | ------- | ---- |
| process.nextTick           | x       | √    |
| MutationObserver           | √       | x    |
| Promise.then catch finally | √       | √    |

**如何分析异步执行的顺序：**

- 首先我们分析有多少个宏任务；
- 在每个宏任务中，分析有多少个微任务；
- 根据调用次序，确定宏任务中的微任务执行次序；
- 根据宏任务的触发规则和调用次序，确定宏任务的执行次序；
- 确定整个顺序。


## generator/iterator：

generator/iterator 也常常被跟异步一起来讲，我们必须说明 generator/iterator 并非异步代码，只是在缺少 async/await 的时候，一些框架（最著名的要数 co）使用这样的特性来模拟 async/await。

但是 generator 并非被设计成实现异步，所以有了 async/await 之后，generator/iterator 来模拟异步的方法应该被废弃。