# 闭包和执行上下文

函数执行过程:
![函数执行过程](images/function-execute.png)

### 名词解释

**Lambda：**
Lambda 表达式，又称 λ 表达式。Lambda表达式基于数学中的λ演算得名。在早期的主流的编程语言是基于 lambda 演算的函数式编程语言，所以这个最初的闭包定义，使用了大量的函数式术语。一个不太精确的描述是“带有一系列信息的λ表达式”。对函数式语言而言，λ表达式其实就是函数。

**词法环境：**
待补充

**闭包：** 
闭包其实只是一个绑定了执行环境的函数，这个函数并不是印在书本里的一条简单的表达式，闭包与普通函数的区别是，它携带了<u>执行的环境</u>，就像人在外星中需要自带吸氧的装备一样，这个函数也带有在程序中生存的环境。

这个古典的闭包定义中，闭包包含两个部分:

- 环境部分
    - 环境
    - 标识符列表
- 表达式部分

JavaScript 的标准中的闭包:

- 环境部分
    - 环境：函数的词法环境（执行上下文的一部分，当获取变量时使用）
    - 标识符列表：函数中用到的未声明的变量（外部引用的变量）
- 表达式部分：函数体

**执行上下文**

JavaScript 标准把一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”，它是执行的基础设施；

因为这部分术语经历了比较多的版本和社区的演绎，所以定义比较混乱，这里我们先来理一下 JavaScript 中的概念。

执行上下文在 ES3 中，包含三个部分。
- scope：作用域，也常常被叫做作用域链。
- variable object：变量对象，用于存储变量的对象。
- this value：this 值。

在 ES5 中，我们改进了命名方式，把执行上下文最初的三个部分改为下面这个样子。
- lexical environment：词法环境，当获取变量时使用。
- variable environment：变量环境，当声明变量时使用。
- this value：this 值。

在 ES2018 中，执行上下文又变成了这个样子，this 值被归入 lexical environment，但是增加了不少内容。
- lexical environment：词法环境，当获取变量或者 this 值时使用。
- variable environment：变量环境，当声明变量时使用。
- code evaluation state：用于恢复代码执行位置。
- Function：执行的任务是函数时使用，表示正在被执行的函数。
- ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。
- Realm：使用的基础库和内置对象实例。
- Generator：仅生成器上下文有这个属性，表示当前生成器。

我们看以下的这段 JavaScript 代码示例进行简单解释：

```js
var b = {}
let c = 1
this.a = 2;
```
要想正确执行它，我们需要知道以下信息：
1. var 把 b 声明到哪里；（哪个作用域可以调用到b）
2. b 表示哪个变量；（b的值是什么）
3. b 的原型是哪个对象；（b的值的原型）
4. let 把 c 声明到哪里；（哪个作用域可以调用到c）
5. this 指向哪个对象。

### var 声明与赋值

var 声明要么是全局作用域，要么在函数中属于函数作用域。在没有let、const时，诞生了一种‘立即执行的函数表达式’（IIFE），通过创建一个函数，并进行自执行来创建作用域，从而控制var的使用范围。

常见的IIFE：
```js
(function(){
    var a;
    //code
}());


(function(){
    var a;
    //code
})();
```
但是，上面代码有个缺点，那就是如果上一行代码不写分号，括号会被解释为上一行代码最末的函数调用，产生完全不符合预期，并且难以调试的行为，加号等运算符也有类似的问题。所以一些推荐不加分号的代码风格规范，会要求在括号前面加上分号。

```js
;(function(){
    var a;
    //code
}())


;(function(){
    var a;
    //code
})()
```

也可以使用 void:
```js
void function(){
    var a;
    //code
}();
```

值得特别注意的是，有时候 var 的特性会导致声明的变量和被赋值的变量是两个 b，JavaScript 中有特例，那就是使用 with 的时候：
```js
var b;
void function(){
    var env = {b:1};
    b = 2;
    console.log("In function b before with:", b); // 2
    with(env) {
        var b = 3;
        console.log("In with b:", b); // 3
        console.log("In env b:", env.b); // 3
    }
    console.log("In function b after with:", b); // 2
}();
console.log("Global b:", b); // undefined
```
可以看到，在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。

var b = 3 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。

### let

为了实现 let，JavaScript 在运行时引入了块级作用域。也就是说，在 let 出现之前，JavaScript 的 if for 等语句皆不产生作用域。

let 作用域的规则是，以 { 开始， } 结束，比如在Chrome控制台中执行以下：

```js
{
    let a = 2;
    console.log(a); // 2
}

console.log(a); // Uncaught ReferenceError: a is not defined
```

### Realm

在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”。这个英文的用法就有点比喻的意思，几个翻译都不太适合 JavaScript 语境，所以这里就不翻译啦。

我们继续来看这段代码：

```js
var b = {}
```

在 ES2016 之前的版本中，标准中甚少提及{}的原型问题。但在实际的前端开发中，通过 iframe 等方式创建多 window 环境并非罕见的操作，所以，这才促成了新概念 Realm 的引入。

Realm 中包含一组完整的内置对象，而且是复制关系。

对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。

以下代码展示了在浏览器环境中获取来自两个 Realm 的对象，它们跟本土的 Object 做 instanceOf 时会产生差异：

```js
var iframe = document.createElement('iframe')
document.documentElement.appendChild(iframe)
iframe.src="javascript:var b = {};"

var b1 = iframe.contentWindow.b;
var b2 = {};

console.log(typeof b1, typeof b2); //object object

console.log(b1 instanceof Object, b2 instanceof Object); //false true
```

可以看到，由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。
